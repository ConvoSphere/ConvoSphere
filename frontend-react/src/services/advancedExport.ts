import type { ChatMessage } from "./chat";
import type { ChatExportOptions } from "../components/chat/ChatExport";

import jsPDF from "jspdf";
import JSZip from "jszip";

interface AdvancedExportOptions extends ChatExportOptions {
  includeHeader?: boolean;
  includeFooter?: boolean;
  pageSize?: "A4" | "Letter" | "Legal";
  orientation?: "portrait" | "landscape";
  margins?: {
    top: number;
    bottom: number;
    left: number;
    right: number;
  };
  font?: {
    family: string;
    size: number;
  };
  styling?: {
    primaryColor: string;
    secondaryColor: string;
    backgroundColor: string;
  };
}

interface BatchExportOptions {
  conversations: Array<{
    id: string;
    title: string;
    messages: ChatMessage[];
  }>;
  format: "json" | "pdf" | "markdown" | "txt" | "csv";
  includeMetadata: boolean;
  includeTimestamps: boolean;
  zipFiles: boolean;
}

class AdvancedExportService {
  async exportToPDF(
    messages: ChatMessage[],
    options: AdvancedExportOptions,
    conversationTitle?: string
  ): Promise<void> {
    try {
      const pdf = new jsPDF(options.orientation || "portrait", "mm", options.pageSize || "A4");
      
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const margin = options.margins || { top: 20, bottom: 20, left: 20, right: 20 };
      const contentWidth = pageWidth - margin.left - margin.right;
      
      let yPosition = margin.top;
      
      // Add header
      if (options.includeHeader !== false) {
        pdf.setFontSize(20);
        pdf.setTextColor(24, 144, 255); // Primary color
        pdf.text(conversationTitle || "Chat Export", pageWidth / 2, yPosition, { align: "center" });
        yPosition += 15;
        
        pdf.setFontSize(12);
        pdf.setTextColor(100, 100, 100);
        pdf.text(`Export Date: ${new Date().toLocaleString()}`, margin.left, yPosition);
        yPosition += 8;
        pdf.text(`Message Count: ${messages.length}`, margin.left, yPosition);
        yPosition += 15;
      }
      
      // Add messages
      pdf.setFontSize(12);
      const lineHeight = 8;
      const maxWidth = contentWidth - 10;
      
      messages.forEach((message, index) => {
        // Check if we need a new page
        if (yPosition > pageHeight - margin.bottom - 50) {
          pdf.addPage();
          yPosition = margin.top;
        }
        
        // Message header
        pdf.setFontSize(14);
        pdf.setTextColor(24, 144, 255);
        const author = message.role === "user" ? "User" : "Assistant";
        pdf.text(author, margin.left, yPosition);
        yPosition += 8;
        
        // Message timestamp
        if (options.includeTimestamps !== false) {
          pdf.setFontSize(10);
          pdf.setTextColor(150, 150, 150);
          const timestamp = new Date(message.timestamp).toLocaleString();
          pdf.text(timestamp, margin.left, yPosition);
          yPosition += 6;
        }
        
        // Message content
        pdf.setFontSize(12);
        pdf.setTextColor(50, 50, 50);
        
        const lines = this.splitTextToSize(message.content, maxWidth, pdf);
        lines.forEach(line => {
          if (yPosition > pageHeight - margin.bottom - 20) {
            pdf.addPage();
            yPosition = margin.top;
          }
          pdf.text(line, margin.left, yPosition);
          yPosition += lineHeight;
        });
        
        yPosition += 10;
      });
      
      // Add footer
      if (options.includeFooter !== false) {
        pdf.setFontSize(10);
        pdf.setTextColor(150, 150, 150);
        pdf.text("Generated by AI Assistant Platform", pageWidth / 2, pageHeight - 10, { align: "center" });
      }
      
      // Save the PDF
      const filename = `${conversationTitle || "chat-export"}-${new Date().toISOString().split('T')[0]}.pdf`;
      pdf.save(filename);
      
    } catch (error) {
      console.error("Error generating PDF:", error);
      throw new Error("Failed to generate PDF");
    }
  }

  async batchExport(options: BatchExportOptions): Promise<void> {
    try {
      const { conversations, format, includeMetadata, includeTimestamps, zipFiles } = options;
      
      if (zipFiles) {
        await this.createZippedBatchExport(conversations, format, includeMetadata, includeTimestamps);
      } else {
        await this.createIndividualBatchExport(conversations, format, includeMetadata, includeTimestamps);
      }
    } catch (error) {
      console.error("Error in batch export:", error);
      throw new Error("Failed to perform batch export");
    }
  }

  async scheduleExport(
    conversationId: string,
    options: AdvancedExportOptions,
    schedule: {
      frequency: "once" | "daily" | "weekly" | "monthly";
      time: string; // HH:mm format
      timezone: string;
      startDate: string;
      endDate?: string;
    }
  ): Promise<string> {
    try {
      // TODO: Implement export scheduling
      const scheduleId = `schedule-${Date.now()}`;
      
      // Save schedule to localStorage for now
      const schedules = JSON.parse(localStorage.getItem("export-schedules") || "[]");
      schedules.push({
        id: scheduleId,
        conversationId,
        options,
        schedule,
        createdAt: new Date().toISOString(),
        status: "active",
      });
      localStorage.setItem("export-schedules", JSON.stringify(schedules));
      
      return scheduleId;
    } catch (error) {
      console.error("Error scheduling export:", error);
      throw new Error("Failed to schedule export");
    }
  }

  async getScheduledExports(): Promise<any[]> {
    try {
      const schedules = JSON.parse(localStorage.getItem("export-schedules") || "[]");
      return schedules;
    } catch (error) {
      console.error("Error getting scheduled exports:", error);
      return [];
    }
  }

  async cancelScheduledExport(scheduleId: string): Promise<void> {
    try {
      const schedules = JSON.parse(localStorage.getItem("export-schedules") || "[]");
      const updatedSchedules = schedules.filter((s: any) => s.id !== scheduleId);
      localStorage.setItem("export-schedules", JSON.stringify(updatedSchedules));
    } catch (error) {
      console.error("Error canceling scheduled export:", error);
      throw new Error("Failed to cancel scheduled export");
    }
  }

  private splitTextToSize(text: string, maxWidth: number, pdf: jsPDF): string[] {
    const words = text.split(' ');
    const lines: string[] = [];
    let currentLine = '';
    
    words.forEach(word => {
      const testLine = currentLine ? `${currentLine} ${word}` : word;
      const testWidth = pdf.getTextWidth(testLine);
      
      if (testWidth > maxWidth && currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    });
    
    if (currentLine) {
      lines.push(currentLine);
    }
    
    return lines;
  }

  private generateTextContent(
    messages: ChatMessage[],
    options: ChatExportOptions,
    conversationTitle?: string
  ): string {
    let content = "";
    
    if (options.includeMetadata !== false) {
      content += `Chat Export: ${conversationTitle || "Untitled"}\n`;
      content += `Export Date: ${new Date().toLocaleString()}\n`;
      content += `Message Count: ${messages.length}\n\n`;
    }
    
    messages.forEach(message => {
      const author = message.role === "user" ? "User" : "Assistant";
      content += `${author}:\n`;
      
      if (options.includeTimestamps !== false) {
        content += `[${new Date(message.timestamp).toLocaleString()}]\n`;
      }
      
      content += `${message.content}\n\n`;
    });
    
    return content;
  }

  private generateMarkdownContent(
    messages: ChatMessage[],
    options: ChatExportOptions,
    conversationTitle?: string
  ): string {
    let content = "";
    
    if (options.includeMetadata !== false) {
      content += `# Chat Export: ${conversationTitle || "Untitled"}\n\n`;
      content += `**Export Date:** ${new Date().toLocaleString()}\n`;
      content += `**Message Count:** ${messages.length}\n\n`;
    }
    
    messages.forEach(message => {
      const author = message.role === "user" ? "ðŸ‘¤ User" : "ðŸ¤– Assistant";
      content += `## ${author}\n\n`;
      
      if (options.includeTimestamps !== false) {
        content += `*${new Date(message.timestamp).toLocaleString()}*\n\n`;
      }
      
      content += `${message.content}\n\n`;
    });
    
    return content;
  }

  private generateCSVContent(
    messages: ChatMessage[],
    options: ChatExportOptions,
    conversationTitle?: string
  ): string {
    let content = "Role,Timestamp,Content\n";
    
    messages.forEach(message => {
      const role = message.role;
      const timestamp = options.includeTimestamps !== false 
        ? new Date(message.timestamp).toISOString()
        : "";
      const content = message.content.replace(/"/g, '""'); // Escape quotes
      
      content += `"${role}","${timestamp}","${content}"\n`;
    });
    
    return content;
  }

  private generatePDFHTML(
    messages: ChatMessage[],
    options: AdvancedExportOptions,
    conversationTitle?: string
  ): string {
    const {
      includeHeader = true,
      includeFooter = true,
      pageSize = "A4",
      orientation = "portrait",
      margins = { top: 20, bottom: 20, left: 20, right: 20 },
      font = { family: "Arial", size: 12 },
      styling = {
        primaryColor: "#1890ff",
        secondaryColor: "#666666",
        backgroundColor: "#ffffff",
      },
    } = options;

    const pageSizeCSS = this.getPageSizeCSS(pageSize, orientation);
    
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>${conversationTitle || "Chat Export"}</title>
        <style>
          @media print {
            @page {
              size: ${pageSize} ${orientation};
              margin: ${margins.top}mm ${margins.right}mm ${margins.bottom}mm ${margins.left}mm;
            }
          }
          
          body {
            font-family: ${font.family}, sans-serif;
            font-size: ${font.size}px;
            line-height: 1.6;
            color: #333;
            background-color: ${styling.backgroundColor};
            margin: 0;
            padding: 20px;
          }
          
          .header {
            text-align: center;
            border-bottom: 2px solid ${styling.primaryColor};
            padding-bottom: 20px;
            margin-bottom: 30px;
          }
          
          .header h1 {
            color: ${styling.primaryColor};
            margin: 0;
            font-size: 24px;
          }
          
          .header .metadata {
            color: ${styling.secondaryColor};
            font-size: 14px;
            margin-top: 10px;
          }
          
          .message {
            margin-bottom: 20px;
            page-break-inside: avoid;
          }
          
          .message-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
          }
          
          .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-weight: bold;
            color: white;
          }
          
          .user-avatar {
            background-color: ${styling.primaryColor};
          }
          
          .assistant-avatar {
            background-color: ${styling.secondaryColor};
          }
          
          .message-info {
            flex: 1;
          }
          
          .message-author {
            font-weight: bold;
            color: ${styling.primaryColor};
          }
          
          .message-time {
            color: ${styling.secondaryColor};
            font-size: 12px;
            margin-left: 10px;
          }
          
          .message-content {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid ${styling.primaryColor};
            white-space: pre-wrap;
          }
          
          .assistant-content {
            background-color: #f0f8ff;
            border-left-color: ${styling.secondaryColor};
          }
          
          .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid ${styling.secondaryColor};
            color: ${styling.secondaryColor};
            font-size: 12px;
          }
          
          .page-break {
            page-break-before: always;
          }
        </style>
      </head>
      <body>
        ${includeHeader ? `
          <div class="header">
            <h1>${conversationTitle || "Chat Export"}</h1>
            <div class="metadata">
              Export Date: ${new Date().toLocaleString()}<br>
              Message Count: ${messages.length}<br>
              Format: PDF
            </div>
          </div>
        ` : ""}
        
        ${messages.map((message, index) => `
          <div class="message">
            <div class="message-header">
              <div class="message-avatar ${message.role === "user" ? "user-avatar" : "assistant-avatar"}">
                ${message.role === "user" ? "ðŸ‘¤" : "ðŸ¤–"}
              </div>
              <div class="message-info">
                <span class="message-author">
                  ${message.role === "user" ? "User" : "Assistant"}
                </span>
                ${options.includeTimestamps ? `
                  <span class="message-time">
                    ${new Date(message.timestamp).toLocaleString()}
                  </span>
                ` : ""}
              </div>
            </div>
            <div class="message-content ${message.role === "assistant" ? "assistant-content" : ""}">
              ${message.content}
            </div>
          </div>
        `).join("")}
        
        ${includeFooter ? `
          <div class="footer">
            Generated by AI Assistant Platform<br>
            ${new Date().toLocaleString()}
          </div>
        ` : ""}
      </body>
      </html>
    `;
  }

  private getPageSizeCSS(pageSize: string, orientation: string): string {
    const sizes = {
      A4: { width: "210mm", height: "297mm" },
      Letter: { width: "8.5in", height: "11in" },
      Legal: { width: "8.5in", height: "14in" },
    };
    
    const size = sizes[pageSize as keyof typeof sizes] || sizes.A4;
    return orientation === "landscape" 
      ? `${size.height} ${size.width}`
      : `${size.width} ${size.height}`;
  }

  private async createZippedBatchExport(
    conversations: Array<{ id: string; title: string; messages: ChatMessage[] }>,
    format: string,
    includeMetadata: boolean,
    includeTimestamps: boolean
  ): Promise<void> {
    try {
      const zip = new JSZip();
      
      for (const conversation of conversations) {
        try {
          const options: ChatExportOptions = {
            format: format as any,
            includeMetadata,
            includeTimestamps,
            includeUserInfo: true,
          };
          
          let content = "";
          let filename = "";
          
          switch (format) {
            case "json":
              content = JSON.stringify(conversation.messages, null, 2);
              filename = `${conversation.title || conversation.id}.json`;
              break;
            case "txt":
              content = this.generateTextContent(conversation.messages, options, conversation.title);
              filename = `${conversation.title || conversation.id}.txt`;
              break;
            case "markdown":
              content = this.generateMarkdownContent(conversation.messages, options, conversation.title);
              filename = `${conversation.title || conversation.id}.md`;
              break;
            case "csv":
              content = this.generateCSVContent(conversation.messages, options, conversation.title);
              filename = `${conversation.title || conversation.id}.csv`;
              break;
            default:
              content = JSON.stringify(conversation.messages, null, 2);
              filename = `${conversation.title || conversation.id}.json`;
          }
          
          zip.file(filename, content);
        } catch (error) {
          console.error(`Error processing conversation ${conversation.id}:`, error);
        }
      }
      
      const zipBlob = await zip.generateAsync({ type: "blob" });
      const url = URL.createObjectURL(zipBlob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `chat-exports-${new Date().toISOString().split('T')[0]}.zip`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
    } catch (error) {
      console.error("Error creating ZIP export:", error);
      throw new Error("Failed to create ZIP export");
    }
  }

  private async createIndividualBatchExport(
    conversations: Array<{ id: string; title: string; messages: ChatMessage[] }>,
    format: string,
    includeMetadata: boolean,
    includeTimestamps: boolean
  ): Promise<void> {
    for (const conversation of conversations) {
      try {
        const options: ChatExportOptions = {
          format: format as any,
          includeMetadata,
          includeTimestamps,
          includeUserInfo: true,
        };
        
        // Use the existing export service
        const { exportService } = await import("./export");
        await exportService.exportChat(conversation.messages, options, conversation.title);
        
        // Add delay between downloads to prevent browser blocking
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        console.error(`Error exporting conversation ${conversation.id}:`, error);
      }
    }
  }
}

export const advancedExportService = new AdvancedExportService();
export default advancedExportService;